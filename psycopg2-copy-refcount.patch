Fix failure to increment the refcount on an object during COPY operations,
per bug #711095.


diff -Naur psycopg2-2.0.13.orig/psycopg/cursor_type.c psycopg2-2.0.13/psycopg/cursor_type.c
--- psycopg2-2.0.13.orig/psycopg/cursor_type.c	2009-10-04 17:35:29.000000000 -0400
+++ psycopg2-2.0.13/psycopg/cursor_type.c	2011-07-08 12:27:36.873137077 -0400
@@ -1184,8 +1184,12 @@
 {
     if (PyObject_HasAttrString(o, "readline")
         && PyObject_HasAttrString(o, "read")) {
-        /* It's OK to store a borrowed reference, because it is only held for
-         * the duration of psyco_curs_copy_from. */
+        /* This routine stores a borrowed reference.  Although it is only held
+         * for the duration of psyco_curs_copy_from, nested invocations of
+         * Py_BEGIN_ALLOW_THREADS could surrender control to another thread,
+         * which could invoke the garbage collector.  We thus need an
+         * INCREF/DECREF pair if we store this pointer in a GC object, such as
+         * a cursorObject */
         *((PyObject**)var) = o;
         return 1;
     }
@@ -1268,6 +1272,7 @@
     Dprintf("psyco_curs_copy_from: query = %s", query);
 
     self->copysize = bufsize;
+    Py_INCREF(file);
     self->copyfile = file;
 
     if (pq_execute(self, query, 0) == 1) {
@@ -1279,6 +1284,7 @@
         PyMem_Free(query);
     }
     self->copyfile = NULL;
+    Py_DECREF(file);
 
     return res;
 }
@@ -1292,8 +1298,6 @@
 _psyco_curs_has_write_check(PyObject* o, void* var)
 {
     if (PyObject_HasAttrString(o, "write")) {
-        /* It's OK to store a borrowed reference, because it is only held for
-         * the duration of psyco_curs_copy_to. */
         *((PyObject**)var) = o;
         return 1;
     }
@@ -1371,6 +1375,7 @@
     Dprintf("psyco_curs_copy_to: query = %s", query);
 
     self->copysize = 0;
+    Py_INCREF(file);
     self->copyfile = file;
 
     if (pq_execute(self, query, 0) == 1) {
@@ -1380,6 +1385,8 @@
     if (query && (query != query_buffer)) {
         PyMem_Free(query);
     }
+
+    Py_DECREF(file);
     self->copyfile = NULL;
 
     return res;
@@ -1414,10 +1421,10 @@
 
     sql = _psyco_curs_validate_sql_basic(self, sql);
     
-    /* Any failure from here forward should 'goto fail' rather than
+    /* Any failure from here forward should 'goto exit' rather than
        'return NULL' directly. */
     
-    if (sql == NULL) { goto fail; }
+    if (sql == NULL) { goto exit; }
 
     /* This validation of file is rather weak, in that it doesn't enforce the
        assocation between "COPY FROM" -> "read" and "COPY TO" -> "write".
@@ -1432,26 +1439,23 @@
         PyErr_SetString(PyExc_TypeError, "file must be a readable file-like"
             " object for COPY FROM; a writeable file-like object for COPY TO."
           );
-        goto fail;
+        goto exit;
     }
 
     self->copysize = bufsize;
+    Py_INCREF(file);
     self->copyfile = file;
 
     /* At this point, the SQL statement must be str, not unicode */
-    if (pq_execute(self, PyString_AS_STRING(sql), 0) != 1) { goto fail; }
-
-    res = Py_None;
-    Py_INCREF(res);
-    goto cleanup;
- fail:
-    if (res != NULL) {
-        Py_DECREF(res);
-        res = NULL;
+    if (pq_execute(self, PyString_AS_STRING(sql), 0) == 1) {
+        res = Py_None;
+        Py_INCREF(res);
     }
-    /* Fall through to cleanup */
- cleanup:
+
     self->copyfile = NULL;
+    Py_DECREF(file);
+
+ exit:
     Py_XDECREF(sql);
 
     return res;
diff -Naur psycopg2-2.0.13.orig/scripts/ticket58.py psycopg2-2.0.13/scripts/ticket58.py
--- psycopg2-2.0.13.orig/scripts/ticket58.py	1969-12-31 19:00:00.000000000 -0500
+++ psycopg2-2.0.13/scripts/ticket58.py	2011-07-08 12:27:36.874138293 -0400
@@ -0,0 +1,75 @@
+"""
+A script to reproduce the race condition described in ticket #58
+
+from https://bugzilla.redhat.com/show_bug.cgi?id=711095
+
+Results in the error:
+
+  python: Modules/gcmodule.c:277: visit_decref: Assertion `gc->gc.gc_refs != 0'
+  failed.
+
+on unpatched library.
+"""
+
+import threading
+import gc
+import time
+
+import psycopg2
+from StringIO import StringIO
+
+done = 0
+
+class GCThread(threading.Thread):
+    # A thread that sits in an infinite loop, forcing the garbage collector
+    # to run
+    def run(self):
+        global done
+        while not done:
+            gc.collect()
+            time.sleep(0.1) # give the other thread a chance to run
+
+gc_thread = GCThread()
+
+
+# This assumes a pre-existing db named "test", with:
+#   "CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);"
+
+conn = psycopg2.connect("dbname=test user=postgres")
+cur = conn.cursor()
+
+# Start the other thread, running the GC regularly
+gc_thread.start()
+
+# Now do lots of "cursor.copy_from" calls:
+print "copy_from"
+for i in range(1000):
+    f = StringIO("42\tfoo\n74\tbar\n")
+    cur.copy_from(f, 'test', columns=('num', 'data'))
+    # Assuming the other thread gets a chance to run during this call, expect a
+    # build of python (with assertions enabled) to bail out here with:
+    #    python: Modules/gcmodule.c:277: visit_decref: Assertion `gc->gc.gc_refs != 0' failed.
+
+# Also exercise the copy_to code path
+print "copy_to"
+cur.execute("truncate test")
+f = StringIO("42\tfoo\n74\tbar\n")
+cur.copy_from(f, 'test', columns=('num', 'data'))
+for i in range(1000):
+    f = StringIO()
+    cur.copy_to(f, 'test', columns=('num', 'data'))
+
+# And copy_expert too
+print "copy_expert"
+cur.execute("truncate test")
+for i in range(1000):
+    f = StringIO("42\tfoo\n74\tbar\n")
+    cur.copy_expert("copy test to stdout", f)
+
+# Terminate the GC thread's loop:
+done = 1
+
+cur.close()
+conn.close()
+
+
